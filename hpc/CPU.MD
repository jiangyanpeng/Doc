# 减少CPU的占用率
1. 选择合适的算法和数据结构
2. 使用尽量小的数据类型
3. 减少运算的强度
   - 3.1 查表
   - 3.2 求余运算
    ```
    // a=a%8;
    a=a&7;
    // 位操作只需一个指令周期即可完成，而大部分的C编译器的“%”运算均是调用子程序来完成，代码长、执行速度慢。通常，只要求是求2n方的余数，均可使用位操作的方法来代替
    ```
   - 3.3 平方运算 
    ```
    // a=pow(a, 2.0);
    a=a*a;
    // a=pow(a，3.0);
    a=a*a*a;
    ```
   - 3.4 用移位实现乘除法运算
    ```
    // a=a*4;
    // b=b/4;
    a = a<<2;
    b = b>>2;

    //  通常如果需要乘以或除以2n，都可以用移位的方法代替。在ICCAVR中，如果乘以2n，都可以生成左移的代码，而乘以其它的整数或除以任何数，均调用乘除法子程序。用移位的方法得到代码比调用乘除法子程序生成的代码效率高。实际上，只要是乘以或除以一个整数，均可以用移位的方法得到结果

    // a=a*9
    a=(a<<3)+a;

    // 总结：
    // x = w % 8;
    // y = pow(x， 2.0);
    // z = y * 33;
    // for (i = 0;i < MAX;i++) {
    //    h = 14 * i;
    //    printf('%d'， h);
    // }
    x = w & 7;                 /* 位操作比求余运算快 */
    y = x * x;                 /* 乘法比平方运算快 */
    z = (y << 5) + y;          /* 位移乘法比乘法快 */
    for (i = h = 0; i < MAX; i++) {
        h += 14;               /* 加法比乘法快 */
        printf('%d'， h);
    }
    ```
   - 3.5 避免不必要的整数除法
    ```
    // 整数除法是整数运算中最慢的，所以应该尽可能避免。一种可能减少整数除法的地方是连除，这里除法可以由乘法代替。这个替换的副作用是有可能在算乘积时会溢出，所以只能在一定范围的除法中使用

    // int i, j, k, m;
    // m = i / j / k;
    int i, j, k, m;
    m = i / (j * k);
    ```
    - 3.6 使用复合赋值表达式
     复合赋值表达式(如a-=1及a+=1等)都能够生成高质量的程序代码
    - 3.7 结构体要数据对齐
    - 3.8 把频繁使用的指针型参数拷贝到本地变量
     避免在函数中频繁使用指针型参数指向的值。因为编译器不知道指针之间是否存在冲突，所以指针型参数往往不能被编译器优化。这样数据不能被存放在寄存器中，而且明显地占用了内存带宽。
    ```
    // void isqrt(unsigned long a， unsigned long* q， unsigned long* r) {
    // 　　*q = a；
    // 　　if (a > 0) {
    // 　　　　while (*q > (*r = a / *q)) {
    // 　　　　　　*q = (*q + *r) >> 1；
    // 　　　　}
    // 　　}
    // 　　*r = a - *q * *q；
    // } 
    void isqrt(unsigned long a， unsigned long* q， unsigned long* r) {
    　　unsigned long qq， rr；
    　　qq = a；
    　　if (a > 0) {
    　　　　while (qq > (rr = a / qq)) {
    　　　　　　qq = (qq + rr) >> 1；
    　　　　}
    　　}
    　　rr = a - qq * qq；
    　　*q = qq；
    　　*r = rr；
    }
    ```
4. 循环优化
   - 4.1 充分分解小的循环
    要充分利用CPU的指令缓存，就要充分分解小的循环。特别是当循环体本身很小的时候，分解循环可以提高性能。注意:很多编译器并不能自动分解循环
    ```
    // 3D转化：把矢量 V 和 4x4 矩阵 M 相乘
    // for (i = 0； i < 4； i ++) {
    //　　r = 0；
    //　　for (j = 0； j < 4； j ++) {
    //　　　　r += M[j]*V[j]；
    //　　}
    // }
    r[0] = M[0][0]*V[0] + M[1][0]*V[1] + M[2][0]*V[2] + M[3][0]*V[3]；
    r[1] = M[0][1]*V[0] + M[1][1]*V[1] + M[2][1]*V[2] + M[3][1]*V[3]；
    r[2] = M[0][2]*V[0] + M[1][2]*V[1] + M[2][2]*V[2] + M[3][2]*V[3]；
    r[3] = M[0][3]*V[0] + M[1][3]*V[1] + M[2][3]*V[2] + M[3][3]*v[3]；
    ```
    - 4.2 while循环和do…while循环
     使用do…while循环编译后生成的代码的长度短于while循环
    - 4.3 循环展开
    - 4.4 循环嵌套
      把相关循环放到一个循环里，也会加快速度。
    - 4.5 Switch语句中根据发生频率来进行case排序
     Switch 可能转化成多种不同算法的代码。其中最常见的是跳转表和比较链/树。当switch用比较链的方式转化时，编译器会产生if-else-if的嵌套代码，并按照顺序进行比较，匹配时就跳转到满足条件的语句执行。所以可以对case的值依照发生的可能性进行排序，把最有可能的放在第一位，这样可以提高性能。此外，在case中推荐使用小的连续的整数，因为在这种情况下，所有的编译器都可以把switch 转化成跳转表。